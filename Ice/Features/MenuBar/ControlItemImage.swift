//
//  ControlItemImage.swift
//  Ice
//

import Cocoa

/// A Codable image for a control item.
enum ControlItemImage: Codable, Hashable {
    /// An image generated by the app.
    case builtin(ImageBuiltin)
    /// A system symbol image.
    case symbol(_ name: String)
    /// An image in an asset catalog.
    case catalog(_ name: String)
    /// An image stored as data.
    case data(_ data: Data)

    /// A Cocoa representation of this image.
    var nsImage: NSImage? {
        switch self {
        case .builtin(let builtin):
            return builtin.nsImage
        case .symbol(let name):
            let image = NSImage(systemSymbolName: name, accessibilityDescription: "")
            image?.isTemplate = true
            return image
        case .catalog(let name):
            return NSImage(named: name)
        case .data(let data):
            return NSImage(data: data)
        }
    }
}

extension ControlItemImage {
    /// An image that is generated by the app.
    enum ImageBuiltin: Codable, Hashable {
        case circleFilled
        case circleStroked
        case chevronLarge
        case chevronSmall

        var nsImage: NSImage {
            switch self {
            case .circleFilled: StaticBuiltins.circleFilled
            case .circleStroked: StaticBuiltins.circleStroked
            case .chevronLarge: StaticBuiltins.chevronLarge
            case .chevronSmall: StaticBuiltins.chevronSmall
            }
        }
    }
}

extension ControlItemImage.ImageBuiltin {
    /// A namespace for static builtin images.
    private enum StaticBuiltins {
        static let circleFilled: NSImage = {
            let image = NSImage(size: CGSize(width: 8, height: 8), flipped: false) { bounds in
                NSColor.black.setFill()
                NSBezierPath(ovalIn: bounds).fill()
                return true
            }
            image.isTemplate = true
            return image
        }()

        static let circleStroked: NSImage = {
            let image = NSImage(size: CGSize(width: 8, height: 8), flipped: false) { bounds in
                let lineWidth: CGFloat = 1.5
                let insetBounds = bounds.insetBy(dx: lineWidth / 2, dy: lineWidth / 2)
                let path = NSBezierPath(ovalIn: insetBounds)
                path.lineWidth = lineWidth
                NSColor.black.setStroke()
                path.stroke()
                return true
            }
            image.isTemplate = true
            return image
        }()

        private static func chevron(size: CGSize, lineWidth: CGFloat) -> NSImage {
            let image = NSImage(size: size, flipped: false) { bounds in
                let insetBounds = bounds.insetBy(dx: lineWidth / 2, dy: lineWidth / 2)
                let path = NSBezierPath()
                path.move(to: CGPoint(x: (insetBounds.midX + insetBounds.maxX) / 2, y: insetBounds.maxY))
                path.line(to: CGPoint(x: (insetBounds.minX + insetBounds.midX) / 2, y: insetBounds.midY))
                path.line(to: CGPoint(x: (insetBounds.midX + insetBounds.maxX) / 2, y: insetBounds.minY))
                path.lineWidth = lineWidth
                path.lineCapStyle = .butt
                NSColor.black.setStroke()
                path.stroke()
                return true
            }
            image.isTemplate = true
            return image
        }

        static let chevronLarge = chevron(size: CGSize(width: 12, height: 12), lineWidth: 2)

        static let chevronSmall = chevron(size: CGSize(width: 9, height: 9), lineWidth: 2)
    }
}
